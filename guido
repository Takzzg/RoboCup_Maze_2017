#include "mbed.h"
#include "Adafruit_BNO055.h"
#include "MotorDC.h"
#include "hcsr04.h"
#include "QEI.h"//---

AnalogIn cny70(A0);
int dist_1;
int dist_2;
int rampa_arriba = 0;
int rampa_abajo = 0;
bool vict_izq = false;
bool vict_der = false;
bool detenido = false;
bool a = true;
float lectura;
//Motores definidos
MotorDC M_izq(PTD3, PTC9, PTB23);  //pwma, ain1, ain2---- M2
MotorDC M_der(PTA1, PTB9, PTC1);  //pwmb, bin1, bin2---- M1
DigitalOut stby(PTC8,1);

#define enc_der_chana PTB11
#define enc_der_chanb PTC11
#define enc_izq_chana PTB10
#define enc_izq_chanb PTB2 //antes ptb20
#define PULSES_PER_REVOLUTION 334
#define BNO055_SAMPLERATE_DELAY_MS (100)

QEI leftQei(enc_izq_chana, enc_izq_chanb, NC, PULSES_PER_REVOLUTION);  //chanA, chanB, index, ppr
QEI rightQei(enc_der_chana, enc_der_chanb, NC, PULSES_PER_REVOLUTION); //chanB, chanA, index, ppr

I2C i2c(PTE25,PTE24);
Adafruit_BNO055 bno = Adafruit_BNO055(55,0x28,&i2c);
imu::Quaternion quat;
imu::Vector<3> vector_euler;
imu::Vector<3> vector_acc;
imu::Vector<3> vector_euler_init;

Ticker update_speed_motors;

float speed_mizq = 0;
float speed_mder = 0;

void updateSpeedMotors(){
  M_izq = speed_mizq;
  M_der = speed_mder;
}

#define TRIGGER PTB3
HCSR04 sensor1(TRIGGER,PTC5);
HCSR04 sensor2(TRIGGER,PTC7);
HCSR04 sensor3(TRIGGER,PTC0);
HCSR04 sensor4(TRIGGER,PTC3);
HCSR04 sensor5(TRIGGER,PTC2);
HCSR04 sensor6(TRIGGER,PTA2);
HCSR04 sensor7(TRIGGER,PTB19);
HCSR04 sensor8(TRIGGER,PTB18);

Serial pc(USBTX, USBRX);

int ult_del_izq , ult_izq_del, ult_izq_tras, ult_tras_izq, ult_tras_der, ult_der_tras, ult_der_del, ult_del_der;
int cero,uno,dos,tres,cuatro,cinco,seis,siete;

#define est_add_info 0
#define est_calcular_dest 1
#define est_recorrer_camino 2
#define est_fin_lab 3

#define sub_calculo_giro 0
#define sub_realizo_giro 1
#define sub_lectura 2
#define sub_negro 3
#define sub_blanco 4

#define point_limit 64
int estado = 0;
int sub_estado = 0;
bool timer_on = false;
int dir = 0;
int pinchila = 1;
int dist_n, dist_o, dist_e, dist_d, dist_se, dist_so;
int GIROS[4] = { 0, -1, 2, 1 };

 void displaySensorStatus(void){
   /* Get the system status values (mostly for debugging purposes) */
   uint8_t system_status, self_test_results, system_error;
   system_status = self_test_results = system_error = 0;
   bno.getSystemStatus(&system_status, &self_test_results, &system_error);
   wait_ms(500);
 }
 
 void init_value_3d_sensor(){
   //wait_ms(1000);
   quat = bno.getQuat();
   vector_euler_init = quat.toEuler();
   vector_euler_init.toDegrees();
   //wait_ms(1000);
 }

 void turn_90(int direction){
  init_value_3d_sensor();
  float eje_x = 0;
  float eje_y = 0;
  float eje_z = 0;
  float grados = 86;

  speed_mizq = 0.8f * direction;
  speed_mder = -0.8f * direction;

  while(fabs(eje_x) < grados){
     quat = bno.getQuat();
     vector_euler = quat.toEuler();
     vector_euler.toDegrees();

     eje_x = vector_euler.x() - vector_euler_init.x();
     if(eje_x > 180) eje_x -= 360;
     if(eje_x < -180) eje_x += 360;
   }
   speed_mizq = 0;
   speed_mder = 0;
   wait_us(1);
 }
 
 void turn_left90(){
   turn_90(-1);
 }
 
 void turn_right90(){
   turn_90(1);
 }
 
 void check_Bno(){
   if(!bno.begin())
   {
     pc.printf("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
     while(1);
   }
   wait(1.0f);
   pc.printf("Iniciando...\n");
   displaySensorStatus();
   Adafruit_BNO055::adafruit_bno055_rev_info_t info;
   bno.setExtCrystalUse(true);
   bno.getRevInfo(&info);
  }
  
void moveTile(int direction){

	  leftQei.reset();
	  rightQei.reset();

	  int leftPulses  = 0;    //How far the left wheel has travelled.
	  int rightPulses = 0;    //How far the right wheel has travelled.
	  int dist_izq = 1205; //Number of pulses to travel.
	  int dist_der = 1293;

	  speed_mizq = 0.8f * direction;
	  speed_mder = 0.8f * direction;
	  wait_us(1);

	  while (abs(leftPulses) <= dist_izq || abs(rightPulses) <= dist_der){
      if(abs(leftPulses) <= dist_izq){
	      leftPulses  = leftQei.getPulses();
	    } 
      else {
	      speed_mizq = 0;
	      wait_us(1);
	    }
	    if(abs(rightPulses) <= dist_der){
	      rightPulses = rightQei.getPulses();
	    } 
      else {
	      speed_mder = 0;
	      wait_us(1);
	    }
	  }
	  speed_mizq = 0; //me aseguro de frenar
	  speed_mder = 0;
	  leftQei.reset();
	  rightQei.reset();
	}
  
void moveTileForward(){
  moveTile(1);
}

void moveTileBackward(){
  moveTile(-1);
}

struct comb_bool {
	bool a;
	bool b;
};

struct pcardinales {
	bool n;
	bool e;
	bool s;
	bool o;
};

struct point {
	int X;
	int Y;
	int Z;
};

struct navpoint {
	int X;
	int Y;
	int Z;
	bool conexiones[6];
	bool f_nav;
	int pond;
	bool f_negro;
	bool f_check;
	bool hay_vict;
	bool is_rampa;
};

struct str_rampa {
  int pbX;
  int pbY;
  int pbZ;
  int paX;
  int paY;
  int paZ;
  int dir_sub;
  bool f_rampa;
}rampa;

struct robot {
	int X;
	int Y;
	int Z;
	int pos_destino;
	int robot_dir;
	int pos_mc;
	int micamino[point_limit];
	int giro;
} masche;

int cant_puntos = 0;
struct navpoint pnavegados[point_limit];

//Devuelve un node con las coordenadas del punto que se encuentra en la dirección dir desde el punto (X, Y)
struct point armar_punto(int X, int Y, int Z, int dir) {
	struct point punto;
	if (dir == 0) Y++;
	else if (dir == 1) X++;
	else if (dir == 2) Y--;
	else if (dir == 3) X--;
	else if (dir == 4) Z--;
	else Z++;
	punto.X = X;
	punto.Y = Y;
	punto.Z = Z;
	return punto;
}

//Busca un punto en el arrego de puntos existentes y devuelve la posición en la que este se encuentra.
//Si no existe devuelve el valor cant_puntos
int buscar_pospunto(int X, int Y, int Z) {
	int pos = cant_puntos;
	for (int i = 0; i < cant_puntos; i++)
		if (pnavegados[i].X == X && pnavegados[i].Y == Y && pnavegados[i].Z == Z) return i;
	return pos;
}

void new_point(int n, int e, int s, int o, bool f_check, bool p_rampa) {
  int pos_m = buscar_pospunto(masche.X, masche.Y, masche.Z);
	if(pos_m == 0) { //checks the robot's current node, and if it does not exists, creates a new empty one
		pnavegados[pos_m].X = masche.X;
		pnavegados[pos_m].Y = masche.Y;
		pnavegados[pos_m].Z = masche.Z;
		pnavegados[pos_m].hay_vict = false;
		pnavegados[pos_m].conexiones[4] = false;
		pnavegados[pos_m].conexiones[5] = false;
		cant_puntos++; //increases the amount of nodes
	}
  pnavegados[pos_m].conexiones[0] = false; //sets allconections as false
  pnavegados[pos_m].conexiones[1] = false;
  pnavegados[pos_m].conexiones[2] = false;
  pnavegados[pos_m].conexiones[3] = false;
	if (n > 25 || n == 0) pnavegados[pos_m].conexiones[0] = true; //if there's no wall, sets the conection as true
	if (e > 25 || e == 0) pnavegados[pos_m].conexiones[1] = true;
	if (s > 25 || s == 0) pnavegados[pos_m].conexiones[2] = true;
	if (o > 25 || o == 0) pnavegados[pos_m].conexiones[3] = true;
  
	pnavegados[pos_m].f_nav = true; //sets the current node as navigated
	pnavegados[pos_m].f_check = f_check; //???
	pnavegados[pos_m].is_rampa = p_rampa; //???

	struct point punto; //creates a new structure of points called punto
	for (int i = 0; i < 4; i++) {
		punto = armar_punto(masche.X, masche.Y, masche.Z, i);
		int pos = buscar_pospunto(punto.X, punto.Y, punto.Z);
		//Si el punto no fue guardado y en la dirección correspondiente hay conexión lo guarda.
		if (pos == cant_puntos && pnavegados[pos_m].conexiones[i]) {
			pnavegados[pos].X = punto.X;
			pnavegados[pos].Y = punto.Y;
			pnavegados[pos].Z = punto.Z;
			pnavegados[pos].hay_vict = false;
			pnavegados[pos].pond = point_limit;
			pnavegados[pos].f_negro = false;
			pnavegados[pos].f_nav = false;
			pnavegados[pos].conexiones[4] = false;
			pnavegados[pos].conexiones[5] = false;
			cant_puntos++;
		}
	}
}

//Devuelve la distancia DX + DY entre dos puntos A y B
int dist_AB(int AX, int AY, int AZ, int BX, int BY, int BZ) {
	return abs(AX - BX) + abs(AY - BY) + abs(AZ - BZ);
}

//Devuelve la dirección que se debe seguir para llegar de un punto A a un punto B
//Si devuelve 4 entonces los puntos tienen una distancia mayor a 1
//Si devuelve 5 entonces los puntos tienen las mismas coordenadas
int armar_dir(int AX, int AY, int AZ, int BX, int BY, int BZ) {
	int dist = dist_AB(AX, AY, AZ, BX, BY, BZ);
	if (dist == 1) {
		if (AX < BX) return 1;
		else if (AY < BY) return 0;
		else if (AY > BY) return 2;
		else if (AX > BX) return 3;
		else if (AZ < BZ) return 5;
		else return 4;
	}
  else if (dist == 0) return 6;
	else return 7;
}

//Al finalizar la ejecución de esta función todos los puntos terminan ponderados de acuerdo a la cantidad mínima de puntos que se deben atravesar para llegar a un punto objetivo.
//El punto objetivo se encontrará en la posición pos.

//Devuelve un boolean = 1 si hay conexión entre dos puntos A, de posición pos_ini, y B, de posición pos_fin, existentes.
//Devuelve un boolean = 1 si hay conexión entre dos puntos A, de posición pos_ini, y B, de posición pos_fin, existentes.
bool bool_conect(int pos_ini, int pos_fin) {
	int dir = armar_dir(pnavegados[pos_ini].X, pnavegados[pos_ini].Y, pnavegados[pos_ini].Z, pnavegados[pos_fin].X, pnavegados[pos_fin].Y, pnavegados[pos_fin].Z);
	//Si el punto fue navegado se conoce las direcciones que se puede seguir desde este
	//y si existe una dirección para ir de un punto a otro se devuelve el valor de verdad de la conexión
	if (dir < 6 && pnavegados[pos_ini].f_nav && !pnavegados[pos_ini].f_negro && !pnavegados[pos_fin].f_negro) return pnavegados[pos_ini].conexiones[dir];
	else return false;
}

//Al finalizar la ejecución de esta función todos los puntos terminan ponderados de acuerdo a la cantidad mínima de puntos que se deben atravesar para llegar a un punto objetivo.
//El punto objetivo se encontrará en la posición pos.
void ponderar(int pos) {
	bool cambios = false;
	//Inicializo las poderaciones
	for (int i = 0; i < cant_puntos; i++) pnavegados[i].pond = cant_puntos;
	int pond_act = 0;
	int X = pnavegados[pos].X;
	int Y = pnavegados[pos].Y;
	int Z = pnavegados[pos].Z;
	pnavegados[pos].pond = pond_act;
	//Ponderizo todos los puntos.
	do {
		cambios = false;
		for (int i = 0; i < cant_puntos; i++) {
			if (pnavegados[i].pond == pond_act) {
				for (int j = 0; j < cant_puntos; j++) {
					if (bool_conect(i, j) && pnavegados[j].pond > pond_act) {
						cambios = true;
						pnavegados[j].pond = pond_act + 1;
					}
				}
			}
		}
		pond_act++;
	} 
  while (cambios);
}
//Realizar función para ponderar puntos hasta encontrar destino.
//Realizar función para elegir destino con ciertas características.
//Esta función devuelve la posición (en el arreglo de puntos guardados) del punto sin navegar más cercano.
//En caso de no haber más puntos sin navegar devuelve el punto de inicio del laberinto.
int new_destino() {
	ponderar(buscar_pospunto(masche.X, masche.Y, masche.Z));
	int dist = cant_puntos;
	int pos = 0;
	for (int i = 0; i < cant_puntos; i++) {
		if (!pnavegados[i].f_nav && pnavegados[i].pond <= dist && !pnavegados[i].f_negro) {
			dist = pnavegados[i].pond;
			pos = i;
		}
	}
	masche.pos_destino = pos;
	return pos;
}

//Realizar función para armar camino con destino al punto navegado en la posición pos_fin del arreglo correspondiente.
void armar_camino(int pos_fin) {
	int pond = pnavegados[pos_fin].pond;
	int pos = pos_fin;    
	bool found;
	//Se llena el arreglo de mi_camino con las direcciones a seguir.
	struct point punto;
	while (pond > 0) {
		found = false;
		for (int i = 0; i < cant_puntos && !found; i++) {
			if (bool_conect(i, pos) && pnavegados[pos].pond - pnavegados[i].pond == 1) {
				found = true;
				pond--;
				masche.micamino[pond] = armar_dir(pnavegados[i].X, pnavegados[i].Y, pnavegados[i].Z, pnavegados[pos].X, pnavegados[pos].Y, pnavegados[pos].Z);
				pos = i;
			}
		}
	}
}

void correccion(){
    cero = sensor1.distance();
    wait_ms(25);
    siete = sensor8.distance();
    wait_ms(25);
    tres = sensor4.distance();
    wait_ms(25);
    cuatro = sensor5.distance();
    wait_ms(25);
    
    if(cero < 15 && siete < 15){
      //pc.printf("Distancia para ALEJARME O ACERCARME\n");
      while(cero != 5){
        cero = sensor1.distance();
        wait_ms(25);
        siete = sensor8.distance();
        wait_ms(25);
        if(cero > 5){
          speed_mizq = 0.4f;
          speed_mder = 0.4f;
          wait_us(1);
        }
        if(cero < 5){
          speed_mizq = -0.4f;
          speed_mder = -0.4f;
          wait_us(1);
        }
      }
      speed_mder = 0;
      speed_mizq = 0;
      wait_us(1);
      do{
        cero = sensor1.distance();
        wait_ms(25);
        siete = sensor8.distance();
        wait_ms(25);
        if(cero < siete) speed_mder = 0.4f;
        else speed_mder = -0.4f;
        wait_us(1);
      } while(cero != siete);
    }
    else if(tres < 15 && cuatro < 15){
      //pc.printf("Distancia para ALEJARME O ACERCARME de atras\n");
      while(tres != 5){
        tres = sensor4.distance();
        wait_ms(25);
        cuatro = sensor5.distance();
        wait_ms(25);
        if(tres > 5){
          speed_mizq = -0.4f;
          speed_mder = -0.4f;
          wait_us(1);
        }
        else if(tres < 5){
          speed_mizq = 0.4f;
          speed_mder = 0.4f;
          wait_us(1);
        }
      }
      speed_mder = 0;
      speed_mizq = 0;
      wait_us(1);
      do{
        tres = sensor4.distance();
        wait_ms(25);
        cuatro = sensor5.distance();
        wait_ms(25);
        if(tres < cuatro) speed_mizq = 0.4f;
        else speed_mizq = -0.4f;
        wait_us(1);
      } while(tres != cuatro);
    }
    speed_mder = 0;
    speed_mizq = 0;
    wait_us(1);

    uno = sensor2.distance();
    wait_ms(25);
    dos = sensor3.distance();
    wait_ms(25);
    cinco = sensor6.distance();
    wait_ms(25);
    seis = sensor7.distance();
    wait_ms(25);
    //pc.printf("Entre a corregir \n");
    if (uno < 20 && dos < 20) {
        speed_mder = 0;
        while (uno - dos != 0) {
            uno = sensor2.distance();
            wait_ms(25);
            dos = sensor3.distance();
            wait_ms(25);
            speed_mizq = -0.4f * abs(uno - dos) / (uno - dos);
        }
        speed_mizq = 0;
        wait_us(1);
    } 
    else if (seis < 20 && cinco < 20) {
        while (seis - cinco != 0) {
            cinco = sensor6.distance();
            wait_ms(25);
            seis = sensor7.distance();
            wait_ms(25);
            speed_mder = -0.4f * abs(seis - cinco) / (seis - cinco);
        }
        speed_mder = 0;
        wait_us(1);
    }
}

void impr_ultras(){
  while(true){
    cero = sensor1.distance_mm();
    wait_ms(20);
    uno = sensor2.distance_mm();
    wait_ms(20);
    dos = sensor3.distance_mm();
    wait_ms(20);
    tres = sensor4.distance_mm();
    wait_ms(20);
    cuatro = sensor5.distance_mm();
    wait_ms(20);
    cinco = sensor6.distance_mm();
    wait_ms(20);
    seis = sensor7.distance_mm();
    wait_ms(20);
    siete = sensor8.distance_mm();
    wait_ms(20);
    pc.printf("\ndist_mm\t0 = %d\t1 = %d\t 2 = %d\t 3 = %d\t 4 = %d\t 5 = %d\t 6 = %d\t 7 = %d\t 8 = %d", cero,uno,dos,tres,cuatro,cinco,seis,siete);
    wait_ms(300);
  }
}

void correccion_maxi(){
  speed_mizq = 0;
  speed_mder = 0;
  uno = sensor2.distance_mm();
  wait_ms(25);
  dos = sensor3.distance_mm();
  wait_ms(25);
  seis = sensor7.distance_mm();
  wait_ms(25);
  cinco = sensor6.distance_mm();
  wait_ms(25);
  if((uno < 50 || dos < 50) && uno < dos + 2){
    speed_mder = -0.5f;
    do{
      uno = sensor2.distance_mm();
      wait_ms(25);
      dos = sensor3.distance_mm();
      wait_ms(25);
    } while(uno < dos + 2);
    speed_mder = 0.4f;
    do{
      uno = sensor2.distance_mm();
      wait_ms(25);
      dos = sensor3.distance_mm();
      wait_ms(25);
    } while(uno> dos + 2);
    speed_mder = 0;
  }
  else if((seis < 50 || cinco < 50) && seis < cinco + 2 ){
    speed_mizq = -0.5f;
    do{
      seis = sensor7.distance_mm();
      wait_ms(25);
      cinco = sensor6.distance_mm();
      wait_ms(25);
    } while(seis < cinco + 2);
    speed_mizq = 0.4f;
    do{
      seis = sensor7.distance_mm();
      wait_ms(25);
      cinco = sensor6.distance_mm();
      wait_ms(25);
    } while(seis > cinco + 2);
    speed_mizq = 0;
  }

  cero = sensor1.distance();
  wait_ms(25);
  tres = sensor4.distance();
  wait_ms(25);
  if(cero < 20){
    while(cero != 4){
      if(cero > 4){
        speed_mizq = 0.4f;
        speed_mder = 0.4f;
      }
      else if(cero < 4){
        speed_mizq = -0.4f;
        speed_mder = -0.4f;
      }
      cero = sensor1.distance();
      wait_ms(25);
    }
    speed_mizq = 0;
    speed_mder = 0;
    do{
      cero = sensor1.distance();
      wait_ms(25);
      siete = sensor8.distance();
      wait_ms(25);
      seis = sensor7.distance();
      wait_ms(25);
      uno = sensor2.distance();
      wait_ms(25);
      if(seis < 7){
        if(cero < siete) speed_mizq = -0.4f;
        if(siete < cero) speed_mizq = 0.4f;
      }
      else{// if(uno < 7){
        if(cero < siete) speed_mder = 0.4f;
        else if (siete < cero) speed_mder = -0.4f;
      }
    } while(cero != siete);
  }
  else if(tres < 20){
    while(tres != 5){
      if(tres > 5){
        speed_mizq = -0.4f;
        speed_mder = -0.4f;
      }
      else if(tres < 5){
        speed_mizq = 0.4f;
        speed_mder = 0.4f;
      }
      tres = sensor4.distance();
      wait_ms(25);
    }
    speed_mizq = 0;
    speed_mder = 0;
    do{
      tres = sensor4.distance();
      wait_ms(25);
      cuatro = sensor5.distance();
      wait_ms(25);
      cinco = sensor6.distance();
      wait_ms(25);
      dos = sensor3.distance();
      wait_ms(25);
      if(cinco < 7){
        if(tres < cuatro) speed_mizq = 0.4f;
        else if (cuatro < tres) speed_mizq = -0.4f;
      }
      else{// if(dos < 7){
        if(tres < cuatro) speed_mder = -0.4f;
        else if (cuatro < tres) speed_mder = 0.4f;
      }
    } while(tres != cuatro);
  }

  tres = sensor4.distance();
  wait_ms(25);
  cuatro = sensor5.distance();
  wait_ms(25);
}

void hay_vict_der() {
	vict_der = 1;
}

void hay_vict_izq() {
	vict_izq = 1;
}

int main() {
	pc.baud(115200); //sets the baud ratefor printing
	update_speed_motors.attach_us(&updateSpeedMotors,500.0f); //500us
  check_Bno(); //checks the 360 sensor is working properly
	rampa.f_rampa = false; //sets the bool of ramp end to false
	estado = est_add_info; //sets the state as add info state
	masche.X = 0; //sets the robot's X position to 0
	masche.Y = 0; //sets the robot's Y position to 0
	masche.pos_mc = 0; // ???
  wait(1);
  
	while (true) {
		if (estado == est_add_info) { //if the robot's state is equal to add info state
			int dist[4] = { 0, 0, 0, 0 }; //creates an array dist of 4 ints
			if(masche.robot_dir == 4) dir = (rampa.dir_sub + 2) % 4; //if robot's dir = 4, sets dir to (rampa.dir_sub + 2) % 4
			if(masche.robot_dir == 5) dir = rampa.dir_sub; //if robot's dir = 5, sets dir to rampa.dir_sub
			if(masche.robot_dir != 4 && masche.robot_dir != 5) dir = masche.robot_dir; // if robot's dir is different to 4 AND 5, sets dir to masche.robot_dir

			int robot_dir = dir; //sets robot_dir = dir
      cero = sensor1.distance(); //read all 8 Ultrasound sensors
      wait_ms(25);
      uno = sensor2.distance();
      wait_ms(25);
      dos = sensor3.distance();
      wait_ms(25);
      tres = sensor4.distance();
      wait_ms(25);
      cuatro = sensor5.distance();
      wait_ms(25);
      cinco = sensor6.distance();
      wait_ms(25);
      seis = sensor7.distance();
      wait_ms(25);
      siete = sensor8.distance();
      wait_ms(25);
      int dist_n [] = {(cero+siete)/2,(cinco+seis)/2,(cuatro+tres)/2,(dos+uno)/2}; //makes an average of each side
      
      for (int i = 0; i < 4; i++) { //sets dist[] as the new average (dist_n[])
				dir = (i + robot_dir) % 4;
        dist[dir] = dist_n[i];
			}
      
			int direc[3] = { (0 + masche.robot_dir) % 4, (1 + masche.robot_dir) % 4, (3 + masche.robot_dir) % 4 };
			bool p_rampa = false; //sets the begining of the ramp as false
			new_point(dist[0], dist[1], dist[2], dist[3], false, p_rampa);
			estado = est_calcular_dest;
		}    

		if (estado == est_calcular_dest) {
			new_destino();
			if (!pnavegados[masche.pos_destino].f_nav || (pnavegados[masche.pos_destino].X == 0 && pnavegados[masche.pos_destino].Y == 0 && pnavegados[masche.pos_destino].Z == 0)) {
				masche.pos_mc = 0;
				armar_camino(masche.pos_destino);
				estado = est_recorrer_camino;
				sub_estado = sub_calculo_giro;
			}
		}
    
		if (estado == est_recorrer_camino) {
			int dir = masche.micamino[masche.pos_mc];
      
			if (sub_estado == sub_calculo_giro) {
				if (masche.robot_dir == 4) dir = (rampa.dir_sub + 2) % 4;
				else if (masche.robot_dir == 5) dir = rampa.dir_sub;
				else dir = masche.robot_dir;
				sub_estado = sub_realizo_giro;
			}
      
			if (sub_estado == sub_realizo_giro) {
				int dir = masche.micamino[masche.pos_mc];
				int robot_dir;
        
				if (dir == 4) dir = (rampa.dir_sub + 2) % 4;
				else if (dir == 5) dir = rampa.dir_sub;
        
				if (masche.robot_dir == 4) robot_dir = (rampa.dir_sub + 2) % 4;
				else if (masche.robot_dir == 5) robot_dir = rampa.dir_sub;
				else robot_dir = masche.robot_dir;
        
				masche.giro = GIROS[(robot_dir - dir + 4) % 4];
				int velocidad = masche.giro / abs(masche.giro);
				if (masche.giro == 1) turn_right90();
				if (masche.giro == -1) turn_left90();
				if (masche.giro == 2) { turn_right90(); turn_right90(); }
        
				masche.robot_dir = masche.micamino[masche.pos_mc];
				bool subir_bajar = false;
				if (masche.robot_dir > 3) subir_bajar = true;
				if (masche.giro == 2 || masche.giro == 1 || masche.giro == -1) correccion_maxi();
				if (masche.giro == 0) {
          speed_mder = 0;
          speed_mizq = 0;
          wait_us(1);
				}
				do {
					if (subir_bajar) subir_bajar = false;
					else if (!rampa.f_rampa && pnavegados[buscar_pospunto(masche.X, masche.Y,masche.Z)].is_rampa && masche.pos_mc + 1 == pnavegados[masche.pos_destino].pond) {
            moveTileForward();
						if (rampa_arriba == 0 && rampa_abajo == 0) pnavegados[masche.pos_destino].is_rampa = false;
						else {
							rampa.f_rampa = true;
							subir_bajar = true;
							if (rampa_abajo == 1) {
								int pos = buscar_pospunto(masche.X, masche.Y,masche.Z);
								rampa.paX = masche.X;
								rampa.paY = masche.Y;
								rampa.paZ = masche.Z; //Guardar posición actual en (paX, paY, paZ)

								rampa.pbX = masche.X;
								rampa.pbY = masche.Y;
								rampa.pbZ = masche.Z - 1; //Guardar posición actual en (pbX, pbY, pbZ)
								pnavegados[masche.pos_destino].X = masche.X;
								pnavegados[masche.pos_destino].Y = masche.Y;
								pnavegados[masche.pos_destino].Z = masche.Z - 1; //Guardar la posición del punto de abajo
								rampa.dir_sub = (masche.robot_dir + 2) % 4;
								pnavegados[pos].conexiones[4] = true; //Guardar conexión hacia abajo en punto actual.
								pnavegados[pos].conexiones[masche.robot_dir] = false;
								pnavegados[masche.pos_destino].conexiones[5] = true;
								masche.micamino[masche.pos_mc] = 4;
							} 
              else {
								int pos = buscar_pospunto(masche.X, masche.Y,masche.Z);
								rampa.pbX = masche.X;
								rampa.pbY = masche.Y;
								rampa.pbZ = masche.Z; //Guardar posición actual en (pbX, pbY, pbZ)

								rampa.paX = masche.X;
								rampa.paY = masche.Y;
								rampa.paZ = masche.Z + 1;
								pnavegados[masche.pos_destino].X = masche.X;
								pnavegados[masche.pos_destino].Y = masche.Y;
								pnavegados[masche.pos_destino].Z = masche.Z + 1; //Guardar la posición del punto de arriba
								rampa.dir_sub = masche.robot_dir;
								pnavegados[pos].conexiones[5] = true; //Guardar conexión hacia abajo en punto actual.
								pnavegados[pos].conexiones[masche.robot_dir] = false;
								pnavegados[masche.pos_destino].conexiones[4] = true;
								masche.micamino[masche.pos_mc] = 5;
							}
							masche.robot_dir = masche.micamino[masche.pos_mc];
						}
					} 
          else moveTileForward();
				} 
        while (subir_bajar);
        correccion_maxi();
				if (detenido) {
					pnavegados[masche.pos_destino].f_negro = true;
          moveTileBackward();
					estado = est_calcular_dest;
				} 
        else {
					masche.pos_mc++;

					if (masche.robot_dir == 0)	masche.Y++;
          else if (masche.robot_dir == 1) masche.X++;
					else if (masche.robot_dir == 2) masche.Y--;
					else if (masche.robot_dir == 3) masche.X--;
					else if (masche.robot_dir == 4) masche.Z--;
					else masche.Z++;

					int pos_p = buscar_pospunto(masche.X, masche.Y, masche.Z);

					if (!pnavegados[pos_p].hay_vict) {
						if (vict_izq) {
							pnavegados[pos_p].hay_vict = true;
							vict_izq = 0;
						}
						if (vict_der) {
							pnavegados[pos_p].hay_vict = true;
							vict_der = 0;
						}
					} 
          else {
            vict_izq = 0;
            vict_der = 0;
					}
					if (masche.pos_mc < pnavegados[masche.pos_destino].pond) sub_estado = sub_calculo_giro;
					else if (masche.pos_destino) estado = est_add_info;
					else estado = est_fin_lab;
				}
			}
		}
		while (estado == est_fin_lab){
        DigitalOut(LED1,a);
        wait_ms(400);
        a = !a;
        wait_ms(400);
    }
  }
}

