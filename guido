#include "mbed.h"
#include "Adafruit_BNO055.h"
#include "MotorDC.h"
#include "hcsr04.h"
#include "QEI.h"//---

AnalogIn cny70(A0);
int dist_1;
int dist_2;
int rampa_arriba = 0;
int rampa_abajo = 0;
bool vict_izq = false;
bool vict_der = false;
bool detenido = false;
bool a = true;
float lectura;
//Motores definidos
MotorDC M_izq(PTD3, PTC9, PTB23);  //pwma, ain1, ain2---- M2
MotorDC M_der(PTA1, PTB9, PTC1);  //pwmb, bin1, bin2---- M1
DigitalOut stby(PTC8,1);

#define enc_der_chana PTB11
#define enc_der_chanb PTC11
#define enc_izq_chana PTB10
#define enc_izq_chanb PTB2 //antes ptb20
#define PULSES_PER_REVOLUTION 334
#define BNO055_SAMPLERATE_DELAY_MS (100)

QEI leftQei(enc_izq_chana, enc_izq_chanb, NC, PULSES_PER_REVOLUTION);  //chanA, chanB, index, ppr
QEI rightQei(enc_der_chana, enc_der_chanb, NC, PULSES_PER_REVOLUTION); //chanB, chanA, index, ppr

I2C i2c(PTE25,PTE24);
Adafruit_BNO055 bno = Adafruit_BNO055(55,0x28,&i2c);
imu::Quaternion quat;
imu::Vector<3> vector_euler;
imu::Vector<3> vector_acc;
imu::Vector<3> vector_euler_init;

Ticker update_speed_motors;

float speed_mizq = 0;
float speed_mder = 0;

void updateSpeedMotors(){
  M_izq = speed_mizq;
  M_der = speed_mder;
}

#define TRIGGER PTB3
HCSR04 sensor1(TRIGGER,PTC5);
HCSR04 sensor2(TRIGGER,PTC7);
HCSR04 sensor3(TRIGGER,PTC0);
HCSR04 sensor4(TRIGGER,PTC3);
HCSR04 sensor5(TRIGGER,PTC2);
HCSR04 sensor6(TRIGGER,PTA2);
HCSR04 sensor7(TRIGGER,PTB19);
HCSR04 sensor8(TRIGGER,PTB18);

Serial pc(USBTX, USBRX);

int ult_del_izq , ult_izq_del, ult_izq_tras, ult_tras_izq, ult_tras_der, ult_der_tras, ult_der_del, ult_del_der;
int cero,uno,dos,tres,cuatro,cinco,seis,siete;

#define est_add_info 0
#define est_calcular_dest 1
#define est_recorrer_camino 2
#define est_fin_lab 3

#define sub_calculo_giro 0
#define sub_realizo_giro 1
#define sub_lectura 2
#define sub_negro 3
#define sub_blanco 4
#define point_limit 64

int estado = 0;
int sub_estado = 0;
bool timer_on = false;
int dir = 0;
int pinchila = 1;
int dist_n, dist_o, dist_e, dist_d, dist_se, dist_so;
int GIROS[4] = { 0, -1, 2, 1 };

 void displaySensorStatus(void){
   /* Get the system status values (mostly for debugging purposes) */
   uint8_t system_status, self_test_results, system_error;
   system_status = self_test_results = system_error = 0;
   bno.getSystemStatus(&system_status, &self_test_results, &system_error);
   wait_ms(500);
 }
 
 void init_value_3d_sensor(){
   //wait_ms(1000);
   quat = bno.getQuat();
   vector_euler_init = quat.toEuler();
   vector_euler_init.toDegrees();
   //wait_ms(1000);
 }

 void turn_90(int direction){
  init_value_3d_sensor();
  float eje_x = 0;
  float eje_y = 0;
  float eje_z = 0;
  float grados = 86;

  speed_mizq = 0.8f * direction;
  speed_mder = -0.8f * direction;

  while(fabs(eje_x) < grados){
     quat = bno.getQuat();
     vector_euler = quat.toEuler();
     vector_euler.toDegrees();

     eje_x = vector_euler.x() - vector_euler_init.x();
     if(eje_x > 180) eje_x -= 360;
     if(eje_x < -180) eje_x += 360;
   }
   speed_mizq = 0;
   speed_mder = 0;
   wait_us(1);
 }
 
 void turn_left90(){
   turn_90(-1);
 }
 
 void turn_right90(){
   turn_90(1);
 }
 
 void check_Bno(){
   if(!bno.begin())
   {
     pc.printf("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
     while(1);
   }
   wait(1.0f);
   pc.printf("Iniciando...\n");
   displaySensorStatus();
   Adafruit_BNO055::adafruit_bno055_rev_info_t info;
   bno.setExtCrystalUse(true);
   bno.getRevInfo(&info);
  }
  
void moveTile(int direction){

	  leftQei.reset();
	  rightQei.reset();

	  int leftPulses  = 0;    //How far the left wheel has travelled.
	  int rightPulses = 0;    //How far the right wheel has travelled.
	  int dist_izq = 1205; //Number of pulses to travel.
	  int dist_der = 1293;

	  speed_mizq = 0.8f * direction;
	  speed_mder = 0.8f * direction;
	  wait_us(1);

	  while (abs(leftPulses) <= dist_izq || abs(rightPulses) <= dist_der){
      if(abs(leftPulses) <= dist_izq){
	      leftPulses  = leftQei.getPulses();
	    } 
      else {
	      speed_mizq = 0;
	      wait_us(1);
	    }
	    if(abs(rightPulses) <= dist_der){
	      rightPulses = rightQei.getPulses();
	    } 
      else {
	      speed_mder = 0;
	      wait_us(1);
	    }
	  }
	  speed_mizq = 0; //me aseguro de frenar
	  speed_mder = 0;
	  leftQei.reset();
	  rightQei.reset();
	}
  
void moveTileForward(){
  moveTile(1);
}

void moveTileBackward(){
  moveTile(-1);
}

struct comb_bool {
	bool a;
	bool b;
};

struct pcardinales {
	bool n;
	bool e;
	bool s;
	bool o;
};

struct point {
	int X; //node's X position
	int Y; //node's Y position
	int Z; //node's Z position
};

struct navpoint {
	int X; //node's X position
	int Y; //node's Y position
	int Z; //node's Z position
	bool conexiones[6]; //array of bools with all posible conections (the 4 cardinal points plus ramp upwards and downwards)
	bool f_nav; //???
	int pond; //???
	bool f_negro; //if it's a black cell
	bool f_check; //if it's a checkpoint
	bool hay_vict; //if there's a victim
	bool is_rampa; //if there's a ramp
};

struct str_rampa {
  int pbX;
  int pbY;
  int pbZ;
  int paX;
  int paY;
  int paZ;
  int dir_sub;
  bool f_rampa;
}rampa;

struct robot {
	int X; //robot's X position
	int Y; //robot's Y position
	int Z; //robot's Z position
	int pos_destino; //???
	int robot_dir; //direction the robot's facing
	int pos_mc; //???
	int micamino[point_limit]; //array of ??? with a maximum of 64
	int giro; //???
} masche;

int cant_puntos = 0; //the amount of nodes starts as 0
struct navpoint pnavegados[point_limit]; //array of nodes with a maximum of 64

struct point armar_punto(int X, int Y, int Z, int dir) {
	struct point punto; //creates a new point called punto
	if (dir == 0) Y++; //if dir = 0, increases Y value
	else if (dir == 1) X++; //if dir = 1, increases X value
	else if (dir == 2) Y--; //if dir = 2, decreases Y value
	else if (dir == 3) X--; //if dir = 3, decreases X value
	else if (dir == 4) Z--; //if dir = 4, decreases Z value
	else Z++; //else increases Z value
	punto.X = X; //sets point's XYZ coordenates equal to the robot´s
	punto.Y = Y;
	punto.Z = Z;
	return punto; //returns punto with it's coordenates
}

int buscar_pospunto(int X, int Y, int Z) { 
	int pos = cant_puntos;
	for (int i = 0; i < cant_puntos; i++) //runs through every known node
		if (pnavegados[i].X == X && pnavegados[i].Y == Y && pnavegados[i].Z == Z) return i; //if the node is found, returns it's position
	return pos; //else returns the amount of nodes
}

void new_point(int n, int e, int s, int o, bool f_check, bool p_rampa) {
  int pos_m = buscar_pospunto(masche.X, masche.Y, masche.Z); //checks if the robot already knows this node
	if(pos_m == 0) { //if it's the first node created
		pnavegados[pos_m].X = masche.X; //the node is on the same XYZ position as the robot
		pnavegados[pos_m].Y = masche.Y;
		pnavegados[pos_m].Z = masche.Z;
		pnavegados[pos_m].hay_vict = false; //there's no victim
		pnavegados[pos_m].conexiones[4] = false; //there's no ramp conection neither upwards nor downwards
		pnavegados[pos_m].conexiones[5] = false;
		cant_puntos++; //increases the amount of nodes
	}
  pnavegados[pos_m].conexiones[0] = false; //sets allconections as false
  pnavegados[pos_m].conexiones[1] = false;
  pnavegados[pos_m].conexiones[2] = false;
  pnavegados[pos_m].conexiones[3] = false;
	if (n > 25 || n == 0) pnavegados[pos_m].conexiones[0] = true; //if there's no wall, sets the conection as true
	if (e > 25 || e == 0) pnavegados[pos_m].conexiones[1] = true;
	if (s > 25 || s == 0) pnavegados[pos_m].conexiones[2] = true;
	if (o > 25 || o == 0) pnavegados[pos_m].conexiones[3] = true;
  
	pnavegados[pos_m].f_nav = true; //sets the current node as navigated
	pnavegados[pos_m].f_check = f_check; //sets as a checkpoint if needed
	pnavegados[pos_m].is_rampa = p_rampa; //sets as the begining of a ramp if needed ???

	struct point punto; //creates a new point called punto
	for (int i = 0; i < 4; i++) {
		punto = armar_punto(masche.X, masche.Y, masche.Z, i); //sets the point's coordinates equal to robot's
		int pos = buscar_pospunto(punto.X, punto.Y, punto.Z); //checks for the current node
		if (pos == cant_puntos && pnavegados[pos_m].conexiones[i]) { //if it's the last point and has at least one conection
			pnavegados[pos].X = punto.X; //sets the last node XYZ position equal to punto's
			pnavegados[pos].Y = punto.Y; 
			pnavegados[pos].Z = punto.Z;
			pnavegados[pos].hay_vict = false; //there's no victim
			pnavegados[pos].pond = point_limit; //sets the pond to 64
			pnavegados[pos].f_negro = false; //it's no black cell
			pnavegados[pos].f_nav = false; //it's no checkpoint
			pnavegados[pos].conexiones[4] = false; //has no conection with a ramp upwards nor downwards
			pnavegados[pos].conexiones[5] = false;
			cant_puntos++; //increases the amount of nodes
		}
	}
}

int dist_AB(int AX, int AY, int AZ, int BX, int BY, int BZ) { //returns the distance between the actual node and the objective node
	return abs(AX - BX) + abs(AY - BY) + abs(AZ - BZ);
}

int armar_dir(int AX, int AY, int AZ, int BX, int BY, int BZ) {
	int dist = dist_AB(AX, AY, AZ, BX, BY, BZ); //sets how far the objective is
	if (dist == 1) { //if the objective is next to the actual nodes
    if (AY < BY) return 0; //returns the direction depending on where the cells are located
		if (AX < BX) return 1; 
		if (AY > BY) return 2;
		if (AX > BX) return 3;
    if (AZ > BZ) return 4;
		if (AZ < BZ) return 5;
	}
  if (dist == 0) return 6; //if it´s the same node returns 6
	else return 7; //else returns 7
}

bool bool_conect(int pos_ini, int pos_fin) {
	int dir = armar_dir(pnavegados[pos_ini].X, pnavegados[pos_ini].Y, pnavegados[pos_ini].Z, pnavegados[pos_fin].X, pnavegados[pos_fin].Y, pnavegados[pos_fin].Z); //sets the direction depending on where it has to go from the actual location
	if (dir < 6 && pnavegados[pos_ini].f_nav && !pnavegados[pos_ini].f_negro && !pnavegados[pos_fin].f_negro) 
    return pnavegados[pos_ini].conexiones[dir]; //if it has to go to a node next to it and isn't fully explored and both are non-black cells
	return false;
}

void ponderar(int pos) {
	bool changes = false; //changes start as false
	for(int i = 0; i < cant_puntos; i++) pnavegados[i].pond = cant_puntos; //set all node's pond to the amount of nodes 
	int pond_act = 0; //pond_act starts as 0
	int X = pnavegados[pos].X; //XYZ coordinates are copied
	int Y = pnavegados[pos].Y;
	int Z = pnavegados[pos].Z;
	pnavegados[pos].pond = pond_act; //sets the node's pond to pond_act
	do {
		changes = false; //resets changes to false
		for (int i = 0; i < cant_puntos; i++) { //runs all nodes
			if (pnavegados[i].pond == pond_act) { //if any node's pond is equal to pond_act
				for (int j = 0; j < cant_puntos; j++) { //re-runs all nodes
					if (bool_conect(i, j) && pnavegados[j].pond > pond_act) { //if it has a path to explore and pnavegados[j].pond es higher than pond_act
						changes = true; //changes changes to true
						pnavegados[j].pond = pond_act + 1; //sets pnavegados[j].pond to pond_act plus one
					}
				}
			}
		}
		pond_act++; increases pond_act
	} 
  while (changes);
}

int new_destino() {
	ponderar(buscar_pospunto(masche.X, masche.Y, masche.Z));
	int dist = cant_puntos;
	int pos = 0;
	for (int i = 0; i < cant_puntos; i++) { //runs all nodes
		if (!pnavegados[i].f_nav && pnavegados[i].pond <= dist && !pnavegados[i].f_negro) {//if it hasn't been fully explored and isn't a black cell and pond is equal or bigger than dist
			dist = pnavegados[i].pond; 
			pos = i;
		}
	}
	masche.pos_destino = pos;
	return pos;
}

//Realizar función para armar camino con destino al punto navegado en la posición pos_fin del arreglo correspondiente.
void armar_camino(int pos_fin) {
	int pond = pnavegados[pos_fin].pond;
	int pos = pos_fin;    
	bool found;
	//Se llena el arreglo de mi_camino con las direcciones a seguir.
	struct point punto;
	while (pond > 0) {
		found = false;
		for (int i = 0; i < cant_puntos && !found; i++) {
			if (bool_conect(i, pos) && pnavegados[pos].pond - pnavegados[i].pond == 1) {
				found = true;
				pond--;
				masche.micamino[pond] = armar_dir(pnavegados[i].X, pnavegados[i].Y, pnavegados[i].Z, pnavegados[pos].X, pnavegados[pos].Y, pnavegados[pos].Z);
				pos = i;
			}
		}
	}
}

void correccion(){
    cero = sensor1.distance();
    wait_ms(25);
    siete = sensor8.distance();
    wait_ms(25);
    tres = sensor4.distance();
    wait_ms(25);
    cuatro = sensor5.distance();
    wait_ms(25);
    
    if(cero < 15 && siete < 15){
      //pc.printf("Distancia para ALEJARME O ACERCARME\n");
      while(cero != 5){
        cero = sensor1.distance();
        wait_ms(25);
        siete = sensor8.distance();
        wait_ms(25);
        if(cero > 5){
          speed_mizq = 0.4f;
          speed_mder = 0.4f;
          wait_us(1);
        }
        if(cero < 5){
          speed_mizq = -0.4f;
          speed_mder = -0.4f;
          wait_us(1);
        }
      }
      speed_mder = 0;
      speed_mizq = 0;
      wait_us(1);
      do{
        cero = sensor1.distance();
        wait_ms(25);
        siete = sensor8.distance();
        wait_ms(25);
        if(cero < siete) speed_mder = 0.4f;
        else speed_mder = -0.4f;
        wait_us(1);
      } while(cero != siete);
    }
    else if(tres < 15 && cuatro < 15){
      //pc.printf("Distancia para ALEJARME O ACERCARME de atras\n");
      while(tres != 5){
        tres = sensor4.distance();
        wait_ms(25);
        cuatro = sensor5.distance();
        wait_ms(25);
        if(tres > 5){
          speed_mizq = -0.4f;
          speed_mder = -0.4f;
          wait_us(1);
        }
        else if(tres < 5){
          speed_mizq = 0.4f;
          speed_mder = 0.4f;
          wait_us(1);
        }
      }
      speed_mder = 0;
      speed_mizq = 0;
      wait_us(1);
      do{
        tres = sensor4.distance();
        wait_ms(25);
        cuatro = sensor5.distance();
        wait_ms(25);
        if(tres < cuatro) speed_mizq = 0.4f;
        else speed_mizq = -0.4f;
        wait_us(1);
      } while(tres != cuatro);
    }
    speed_mder = 0;
    speed_mizq = 0;
    wait_us(1);

    uno = sensor2.distance();
    wait_ms(25);
    dos = sensor3.distance();
    wait_ms(25);
    cinco = sensor6.distance();
    wait_ms(25);
    seis = sensor7.distance();
    wait_ms(25);
    //pc.printf("Entre a corregir \n");
    if (uno < 20 && dos < 20) {
        speed_mder = 0;
        while (uno - dos != 0) {
            uno = sensor2.distance();
            wait_ms(25);
            dos = sensor3.distance();
            wait_ms(25);
            speed_mizq = -0.4f * abs(uno - dos) / (uno - dos);
        }
        speed_mizq = 0;
        wait_us(1);
    } 
    else if (seis < 20 && cinco < 20) {
        while (seis - cinco != 0) {
            cinco = sensor6.distance();
            wait_ms(25);
            seis = sensor7.distance();
            wait_ms(25);
            speed_mder = -0.4f * abs(seis - cinco) / (seis - cinco);
        }
        speed_mder = 0;
        wait_us(1);
    }
}

void impr_ultras(){
  while(true){
    cero = sensor1.distance_mm();
    wait_ms(20);
    uno = sensor2.distance_mm();
    wait_ms(20);
    dos = sensor3.distance_mm();
    wait_ms(20);
    tres = sensor4.distance_mm();
    wait_ms(20);
    cuatro = sensor5.distance_mm();
    wait_ms(20);
    cinco = sensor6.distance_mm();
    wait_ms(20);
    seis = sensor7.distance_mm();
    wait_ms(20);
    siete = sensor8.distance_mm();
    wait_ms(20);
    pc.printf("\ndist_mm\t0 = %d\t1 = %d\t 2 = %d\t 3 = %d\t 4 = %d\t 5 = %d\t 6 = %d\t 7 = %d\t 8 = %d", cero,uno,dos,tres,cuatro,cinco,seis,siete);
    wait_ms(300);
  }
}

void correccion_maxi(){
  speed_mizq = 0;
  speed_mder = 0;
  uno = sensor2.distance_mm();
  wait_ms(25);
  dos = sensor3.distance_mm();
  wait_ms(25);
  seis = sensor7.distance_mm();
  wait_ms(25);
  cinco = sensor6.distance_mm();
  wait_ms(25);
  if((uno < 50 || dos < 50) && uno < dos + 2){
    speed_mder = -0.5f;
    do{
      uno = sensor2.distance_mm();
      wait_ms(25);
      dos = sensor3.distance_mm();
      wait_ms(25);
    } while(uno < dos + 2);
    speed_mder = 0.4f;
    do{
      uno = sensor2.distance_mm();
      wait_ms(25);
      dos = sensor3.distance_mm();
      wait_ms(25);
    } while(uno> dos + 2);
    speed_mder = 0;
  }
  else if((seis < 50 || cinco < 50) && seis < cinco + 2 ){
    speed_mizq = -0.5f;
    do{
      seis = sensor7.distance_mm();
      wait_ms(25);
      cinco = sensor6.distance_mm();
      wait_ms(25);
    } while(seis < cinco + 2);
    speed_mizq = 0.4f;
    do{
      seis = sensor7.distance_mm();
      wait_ms(25);
      cinco = sensor6.distance_mm();
      wait_ms(25);
    } while(seis > cinco + 2);
    speed_mizq = 0;
  }

  cero = sensor1.distance();
  wait_ms(25);
  tres = sensor4.distance();
  wait_ms(25);
  if(cero < 20){
    while(cero != 4){
      if(cero > 4){
        speed_mizq = 0.4f;
        speed_mder = 0.4f;
      }
      else if(cero < 4){
        speed_mizq = -0.4f;
        speed_mder = -0.4f;
      }
      cero = sensor1.distance();
      wait_ms(25);
    }
    speed_mizq = 0;
    speed_mder = 0;
    do{
      cero = sensor1.distance();
      wait_ms(25);
      siete = sensor8.distance();
      wait_ms(25);
      seis = sensor7.distance();
      wait_ms(25);
      uno = sensor2.distance();
      wait_ms(25);
      if(seis < 7){
        if(cero < siete) speed_mizq = -0.4f;
        if(siete < cero) speed_mizq = 0.4f;
      }
      else{// if(uno < 7){
        if(cero < siete) speed_mder = 0.4f;
        else if (siete < cero) speed_mder = -0.4f;
      }
    } while(cero != siete);
  }
  else if(tres < 20){
    while(tres != 5){
      if(tres > 5){
        speed_mizq = -0.4f;
        speed_mder = -0.4f;
      }
      else if(tres < 5){
        speed_mizq = 0.4f;
        speed_mder = 0.4f;
      }
      tres = sensor4.distance();
      wait_ms(25);
    }
    speed_mizq = 0;
    speed_mder = 0;
    do{
      tres = sensor4.distance();
      wait_ms(25);
      cuatro = sensor5.distance();
      wait_ms(25);
      cinco = sensor6.distance();
      wait_ms(25);
      dos = sensor3.distance();
      wait_ms(25);
      if(cinco < 7){
        if(tres < cuatro) speed_mizq = 0.4f;
        else if (cuatro < tres) speed_mizq = -0.4f;
      }
      else{// if(dos < 7){
        if(tres < cuatro) speed_mder = -0.4f;
        else if (cuatro < tres) speed_mder = 0.4f;
      }
    } while(tres != cuatro);
  }

  tres = sensor4.distance();
  wait_ms(25);
  cuatro = sensor5.distance();
  wait_ms(25);
}

void hay_vict_der() {
	vict_der = 1;
}

void hay_vict_izq() {
	vict_izq = 1;
}

int main() {
	pc.baud(115200); //sets the baud ratefor printing
	update_speed_motors.attach_us(&updateSpeedMotors,500.0f); //500us
  check_Bno(); //checks the 360 sensor is working properly
	rampa.f_rampa = false; //sets the bool of ramp end to false
	estado = est_add_info; //sets the state as add info state
	masche.X = 0; //sets the robot's X position to 0
	masche.Y = 0; //sets the robot's Y position to 0
	masche.pos_mc = 0; // ???
  wait(1);
  
	while (true) {
		if (estado == est_add_info) { //if the robot's state is equal to add info state
			int dist[4] = { 0, 0, 0, 0 }; //creates an array dist of 4 ints
			if(masche.robot_dir == 4) dir = (rampa.dir_sub + 2) % 4; //if robot's dir = 4, sets dir to (rampa.dir_sub + 2) % 4
			if(masche.robot_dir == 5) dir = rampa.dir_sub; //if robot's dir = 5, sets dir to rampa.dir_sub
			if(masche.robot_dir != 4 && masche.robot_dir != 5) dir = masche.robot_dir; // if robot's dir is different to 4 AND 5, sets dir to masche.robot_dir

			int robot_dir = dir; //sets robot_dir = dir
      cero = sensor1.distance(); //read all 8 Ultrasound sensors
      wait_ms(25);
      uno = sensor2.distance();
      wait_ms(25);
      dos = sensor3.distance();
      wait_ms(25);
      tres = sensor4.distance();
      wait_ms(25);
      cuatro = sensor5.distance();
      wait_ms(25);
      cinco = sensor6.distance();
      wait_ms(25);
      seis = sensor7.distance();
      wait_ms(25);
      siete = sensor8.distance();
      wait_ms(25);
      int dist_n [] = {(cero+siete)/2,(cinco+seis)/2,(cuatro+tres)/2,(dos+uno)/2}; //makes an average of each side
      
      for (int i = 0; i < 4; i++) { //sets dist[] as the new average (dist_n[])
				dir = (i + robot_dir) % 4;
        dist[dir] = dist_n[i];
			}
      
			int direc[3] = { (0 + masche.robot_dir) % 4, (1 + masche.robot_dir) % 4, (3 + masche.robot_dir) % 4 }; //???
			new_point(dist[0], dist[1], dist[2], dist[3], false, false); //creates a new node with no ramp nor checkpoint
			estado = est_calcular_dest; //sets the robot's state to calculate destiny state
		}

		if (estado == est_calcular_dest) {
			new_destino();
			if (!pnavegados[masche.pos_destino].f_nav || (pnavegados[masche.pos_destino].X == 0 && pnavegados[masche.pos_destino].Y == 0 && pnavegados[masche.pos_destino].Z == 0)) {
				masche.pos_mc = 0;
				armar_camino(masche.pos_destino);
				estado = est_recorrer_camino;
				sub_estado = sub_calculo_giro;
			}
		}
    
		if (estado == est_recorrer_camino) {
			int dir = masche.micamino[masche.pos_mc];
      
			if (sub_estado == sub_calculo_giro) {
				if (masche.robot_dir == 4) dir = (rampa.dir_sub + 2) % 4;
				else if (masche.robot_dir == 5) dir = rampa.dir_sub;
				else dir = masche.robot_dir;
				sub_estado = sub_realizo_giro;
			}
      
			if (sub_estado == sub_realizo_giro) {
				int dir = masche.micamino[masche.pos_mc];
				int robot_dir;
        
				if (dir == 4) dir = (rampa.dir_sub + 2) % 4;
				else if (dir == 5) dir = rampa.dir_sub;
        
				if (masche.robot_dir == 4) robot_dir = (rampa.dir_sub + 2) % 4;
				else if (masche.robot_dir == 5) robot_dir = rampa.dir_sub;
				else robot_dir = masche.robot_dir;
        
				masche.giro = GIROS[(robot_dir - dir + 4) % 4];
				int velocidad = masche.giro / abs(masche.giro);
				if (masche.giro == 1) turn_right90();
				if (masche.giro == -1) turn_left90();
				if (masche.giro == 2) { turn_right90(); turn_right90(); }
        
				masche.robot_dir = masche.micamino[masche.pos_mc];
				bool subir_bajar = false;
				if (masche.robot_dir > 3) subir_bajar = true;
				if (masche.giro == 2 || masche.giro == 1 || masche.giro == -1) correccion_maxi();
				if (masche.giro == 0) {
          speed_mder = 0;
          speed_mizq = 0;
          wait_us(1);
				}
				do {
					if (subir_bajar) subir_bajar = false;
					else if (!rampa.f_rampa && pnavegados[buscar_pospunto(masche.X, masche.Y,masche.Z)].is_rampa && masche.pos_mc + 1 == pnavegados[masche.pos_destino].pond) {
            moveTileForward();
						if (rampa_arriba == 0 && rampa_abajo == 0) pnavegados[masche.pos_destino].is_rampa = false;
						else {
							rampa.f_rampa = true;
							subir_bajar = true;
							if (rampa_abajo == 1) {
								int pos = buscar_pospunto(masche.X, masche.Y,masche.Z);
								rampa.paX = masche.X;
								rampa.paY = masche.Y;
								rampa.paZ = masche.Z; //Guardar posición actual en (paX, paY, paZ)

								rampa.pbX = masche.X;
								rampa.pbY = masche.Y;
								rampa.pbZ = masche.Z - 1; //Guardar posición actual en (pbX, pbY, pbZ)
								pnavegados[masche.pos_destino].X = masche.X;
								pnavegados[masche.pos_destino].Y = masche.Y;
								pnavegados[masche.pos_destino].Z = masche.Z - 1; //Guardar la posición del punto de abajo
								rampa.dir_sub = (masche.robot_dir + 2) % 4;
								pnavegados[pos].conexiones[4] = true; //Guardar conexión hacia abajo en punto actual.
								pnavegados[pos].conexiones[masche.robot_dir] = false;
								pnavegados[masche.pos_destino].conexiones[5] = true;
								masche.micamino[masche.pos_mc] = 4;
							} 
              else {
								int pos = buscar_pospunto(masche.X, masche.Y,masche.Z);
								rampa.pbX = masche.X;
								rampa.pbY = masche.Y;
								rampa.pbZ = masche.Z; //Guardar posición actual en (pbX, pbY, pbZ)

								rampa.paX = masche.X;
								rampa.paY = masche.Y;
								rampa.paZ = masche.Z + 1;
								pnavegados[masche.pos_destino].X = masche.X;
								pnavegados[masche.pos_destino].Y = masche.Y;
								pnavegados[masche.pos_destino].Z = masche.Z + 1; //Guardar la posición del punto de arriba
								rampa.dir_sub = masche.robot_dir;
								pnavegados[pos].conexiones[5] = true; //Guardar conexión hacia abajo en punto actual.
								pnavegados[pos].conexiones[masche.robot_dir] = false;
								pnavegados[masche.pos_destino].conexiones[4] = true;
								masche.micamino[masche.pos_mc] = 5;
							}
							masche.robot_dir = masche.micamino[masche.pos_mc];
						}
					} 
          else moveTileForward();
				} 
        while (subir_bajar);
        correccion_maxi();
				if (detenido) {
					pnavegados[masche.pos_destino].f_negro = true;
          moveTileBackward();
					estado = est_calcular_dest;
				} 
        else {
					masche.pos_mc++;

					if (masche.robot_dir == 0)	masche.Y++;
          else if (masche.robot_dir == 1) masche.X++;
					else if (masche.robot_dir == 2) masche.Y--;
					else if (masche.robot_dir == 3) masche.X--;
					else if (masche.robot_dir == 4) masche.Z--;
					else masche.Z++;

					int pos_p = buscar_pospunto(masche.X, masche.Y, masche.Z);

					if (!pnavegados[pos_p].hay_vict) {
						if (vict_izq) {
							pnavegados[pos_p].hay_vict = true;
							vict_izq = 0;
						}
						if (vict_der) {
							pnavegados[pos_p].hay_vict = true;
							vict_der = 0;
						}
					} 
          else {
            vict_izq = 0;
            vict_der = 0;
					}
					if (masche.pos_mc < pnavegados[masche.pos_destino].pond) sub_estado = sub_calculo_giro;
					else if (masche.pos_destino) estado = est_add_info;
					else estado = est_fin_lab;
				}
			}
		}
		while (estado == est_fin_lab){
        DigitalOut(LED1,a);
        wait_ms(400);
        a = !a;
        wait_ms(400);
    }
  }
}
